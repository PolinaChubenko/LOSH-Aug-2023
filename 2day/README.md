# База C++

## Первая программа
- в программе обязательно должна быть функция `main` - это главная исполняемая функция в программе 
- для ввода-вывода нужен заголовочный файл `iostream`
- `std::cin` - стандартный поток ввода, а `std::cout` - вывода
- символ перевода строки `\n` - это спецсимвол (все спецсимволы начинаются с `\`, например, `\t` - tab и т.д.)
- еще существует `std::endl`. Это тоже перенос строки, но отличие в том, что он очищает буфер вывода, а `\n` – нет

Код (файл `main.cpp`):

```cpp
#include <iostream>

int main() {
    int a;     // объявляем целочисленную переменную a
    std::cin >> a;
    std::cout << a + 10 << '\n';
    std::cout << "success" << std::endl;
    return 0;
}
```

## Что такое компиляция?
При компиляции наш код превращается в исполняемый файл т.е. машинный код. 
Поэтому вызываем компилятор, чтобы преобразовать человекочитаемый код и машинный.

## Основные типы
С++ является статически-типизированным языком, то есть на момент компиляции все типы должны быть известны (в отличие от python).

Основные типы, с которым работают:


![types](https://github.com/PolinaChubenko/LOSH-Aug-2023/assets/70897695/433dbb9c-1a54-40f9-ba41-d755057b7dc7)

```cpp
int main() {
    int x = 5;
    double y;
    long long a, b;
    char c, ch = 'g';

    bool flag = true;
    bool new_flag = 1;     // любое положительное число даст значение true
    bool bad_flag = 0;     // значение false
}
```
Хм, а что если сделать так?
```cpp
int main() {
    int a = 5;
    long long b = 10;
    std::cout << a * b;   // какого типа a * b?
}
```
На этот случай С++ продумал очень полезный механизм.

**Integer promotioin** : ''меньший'' тип приводится к ''большему''

## if, for, while

### Операторы if и if-else
```
if (условие)
{
    инструкции;
}
```
Пример кода:
```cpp
int main() {
    int x = 42;
    if (x > 0) {
        std::cout << "positive\n";
    } else if (x == 0) {
         std::cout << "zero\n";
    } else {
        std::cout << "negative\n";
    }
}
```
### Тернарный оператор
Тернарный оператор в некотором роде похож на конструкцию if-else. Он принимает три параметра в следующем виде:

`условие ? операнд_1 : операнд_2`

Если `условие` верно (равно true), тогда выбирается `операнд_1`, который помещается после символа `?`. Если условие не верно, тогда выбирается `операнд_2`, который помещается после `:`.
```cpp
int main() {
    int x = 42;

    if (x > 0) {
        std::cout << "positive\n";
    } else {
        std::cout << "negative\n";
    }

    // эквивалентно

    std::cout << (x > 0 ? "positive" : "negative") << "\n";
}
```
> Важно, что операнды должны быть одного типа!

### Оператор while
Оператор `while` повторяет код в своём теле до тех пор, пока выполняет условие. 
```
while (условие) {
    инструкции;
}
```
Например:
```cpp
int main() {
    int i = 0;
    while (i < 10) {
        i = i + 1;
    }
}
```

### Оператор for 
Циклы с оператором `for` позволяют объединить инициализацию переменных, условие и изменение этих переменных.
```
for (инициализация; условие; изменение) {
    инструкции;
}
```
Пример 1:
```cpp
int main() {
    for (int i = 0; i < 10; ++i) {
        // do something
    }
}
```
Пример 2:
```cpp
int main() {
    for (int i = 0, j = 5; i < 3 && j > 0; ++i, j*=2) {
        std::cout << i << " " << j << "\n";
    }
    // 0 5
    // 1 10
    // 2 20
}
```

### Операторы break и continue
Эти операторы применимы для `for` и `while`, то есть для циклов.
- Оператор `break` прерывает выполнение цикла раньше, чем выполниться условие.
```cpp
int main() {
    int i = 15;
    while (i < 50) {
        if (i < 0) {
            break;
        }
        i = i - 5;
    }
}
```
- Оператор `continue` позволяет прервать итерацию цикла и начать новую итерацию цикла до выполнения всего кода в теле цикла.
```cpp
int main() {
    int i = 0;
    while (i < 5) {
        if (i == 3) {
            i = i + 1;
            continue;
        }
        std::cout << i << " ";
        i = i + 1;
    }
    // 0 1 2 4
}
```

## Функции
Функции позволяют отделить часто используемый код и переиспользовать его с разными значениями аргументов. С примером функции мы уже знакомы: в каждой программе вы пишете функцию `main`, которая не принимает аргументов и возвращает `int`.

Напишем простейшую функцию, вычисляющую произведение двух целых чисел:
```cpp
int Multiply(int a, int b) {  // в заголовке функции указывается тип возвращаемого значения и типы аргументов
    return a * b;
}
```
Если функция ничего не должна возвращать, её можно объявить как `void`:
```cpp
void DoSomething(double d, char c) {
    // ...
    // писать return в конце такой функции не обязательно,
    //     но если требуется завершить функцию (ex: при каком-то условии), можно написать просто return;
}
 
int main() {
    int x = 17, y = 42;
    int z = Multiply(x, y);
    DoSomething(3.14, '@');
}
```
Вот пример рекурсивной функции, вычисляющей факториал:
```cpp
int Factorial(int n) {
    if (n == 0) {
        return 1;
    }
    return n * Factorial(n - 1);  // рекурсивный вызов
}
 
int main() {
    std::cout << Factorial(5) << "\n";  // 120
}
```

Рассмотрим интересный пример:
```cpp
void f(int a, int b) {
    a += b;
}

int main() {
    int a = 5, b = 6;
    f(a, b);
    std::cout << a << " " << b;
} 
```
Вывод программы: `5 6`

Объяснение: параметры в функции по умолчанию передаются ''по значению''. Другими словами, функция работает с копиями аргументов.

## Массивы
Массив это структура данных, представленная в виде группы ячеек одного типа, объединенных под одним единым именем. Массивы используются для обработки большого количества однотипных данных. Отдельная ячейка данных массива называется элементом массива. Элементами массива могут быть  данные любого типа.
> Имя массива является указателем, что такое указатели расскажу немного позже.

Иллюстрация массива (значение элементов массива и индексация массива):

![image17 1](https://github.com/PolinaChubenko/LOSH-Aug-2023/assets/70897695/5cef66a8-eb3b-4507-9adb-8f3256d48862)

Заметьте, что максимальный индекс одномерного массива `a` равен 15, но размер массива 16 ячеек, потому что нумерация ячеек массива всегда начинается с 0. Индекс ячейки – это целое неотрицательное число, по которому можно обращаться к каждой ячейке массива и выполнять какие-либо действия над ней (ячейкой).

Пример объявления массива `a` размера 16 для целочисленных переменных:
```cpp
int main() {
    // тип_переменной название_массива [длина_массива]
    int a[16];     // массив имеет 16 чисел, но все эти числа имеют неопределенное значение
}
```
Другие способы:
```cpp
int main() {
    int mas[10], arr[25]; 

    // массивы могут быть инициализированы при объявлении (это называется списком инициализации)
    int a[16] = { 5, -12, -12, 9, 10, 0, -9, -12, -1, 23, 65, 64, 11, 43, 39, -15 };
    int b[4] {};               //  {0, 0, 0, 0}
    int numbers[4] {1, 2};     //  {1, 2, 0, 0}
}
```
При этом не допускается присвоение одному массиву другого массива:
```cpp
int main() {
    int nums1[] {1,2,3,4,5};
    int nums2[] = nums1;    // ошибка
}
```
Например, получим и изменим значения элементов:
```cpp
int main(){
    int numbers[4] {1,2,3,4};
    int first = numbers[0];                   // получаем первый элемент
    std::cout << first << std::endl;          // 1
    numbers[0] = 34;                          // изменяем значение элемента
    std::cout << numbers[0] << std::endl;     // 34
}
```
Используя циклы, можно пробежаться по всему массиву и через индексы обратиться к его элементам:
```cpp
int main() {   
    const int n = 4;             // константа => неизменяемая переменная
    int a[n] {11, 12, 13, 14};   // массивы можно создавать только КОНСТАНТНОГО размера
    for (int i = 0; i < n; ++i) {
        std::cout << a[i] << std::endl;
    }
}
```
Чтобы пройтись по массиву в цикле, надо знать его длину. Здесь длина задана `константой n`.


## Вердикты CE, RE, UB
### CE - compiler error
Ошибка компиляции возникает, когда код написан некорректно с точки зрения языка. Из такого кода не получается создать исполняемый файл. Примеры:

1. Лексические: компилятор увидел последовательность символов, которую не смог расшифровать.
   - `(std) (::) (cout) (<<) (x) (;)` - пример корретного разбития на токены, и компилятор понял, что хочет программист
   - `)24abracadabra;` - тут все плохо
2. Синтаксическая: возникает, когда вы пишете инструкцию, недопустимую в соответствии с грамматикой языка (примером служит речь мастера Йоды).
   - `x + 5 + ;`
   - нет точки с запятой (;)
   - несоответствие круглых или фигурных скобок
3. Семантическая: возникает, когда инструкция написано корректно, но компилятор её выполнить не может (например: съешьте себя этим столом)
   - использование необъявленных переменных
   - вызов метода `size()` от переменной типа `int`
   - вызов `foo(3);` хотя сигнатура такая: `void foo(int a, int b) {}`

### RE - Runtime Error
Программа компилируется корректно, но в ходе выполнения она делает что-то непотребное. RE невозможно отследить на этапе компиляции (компилятор может разве что кинуть предупреждение в месте потенциальной ошибки). Примеры:

- слишком большая глубина рекурсии (stack overflow) => segmentation fault
- слишком далекий выход за границу массива => segmentation fault
- целочисленное деление на ноль (не всегда компилятор такое может предвидеть)


### UB - undefined behavior
Возникает при выполнении кода, когда результат исполнения которого не описан в стандарте. В случае UB компилятор волен сделать все что угодно (в теории компилятор может взорвать компьютер). UB может переродиться в CE, RE, или пройти незамеченным и нормально отработать.
- Чтение выделенной, но неинициализированной памяти. В теории, считается какой-то мусор, но технически, так как это UB, компилятор вправе поджечь ваш монитор
- Отсутствие return в конце функции, которая что-то возвращает. Шок, да? Это UB!
- Выход за границы C-style массива


## Стандартные контейнеры: std::string, std::vector
Вектор (`std::vector`) и строка (`std::string`) — это важные базовые контейнеры стандартной библиотеки C++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих контейнера предоставляют доступ к элементам по индексу и позволяют эффективно добавлять новые элементы в конец.

В стандартной библиотеке C++ вектором (`std::vector`) называется _динамический_ массив, обеспечивающий быстрое добавление новых элементов в конец и **меняющий** свой размер при необходимости.

Для работы с вектором нужно подключить заголовочный файл `vector`.

Элементы вектора должны быть одинакового типа, и этот тип должен быть известен при компиляции программы. Он задаётся в угловых скобках после `std::vector`: например, `std::vector<int>` — это вектор целых чисел типа `int`, а `std::vector<std::string>` — вектор строк.

Рассмотрим пример программы, которая заполняет вектор элементами и печатает их через пробел:
```cpp
#include <iostream>
#include <vector>
 
int main() {
    std::vector<int> data = {1, 2, 3, 4, 5};
    std::cout << "Size: " << data.size() << "\n";   // 5
    for (int i = 0; i < data.size(); ++i) {
        std::cout << data[i] << " ";
    }
    std::cout << "\n";
}
```
Здесь мы инициализируем вектор через список инициализации, в котором элементы перечислены через запятую.
> Обращение по индексу аналогично обычному С-шному массиву

Другой способ инициализации вектора — указать число элементов и (при необходимости) образец элемента:
```cpp
#include <vector>
 
int main() {
    std::vector<long long> v1;              // пустой вектор
    std::vector<long long> v2(5);           // вектор из пяти чисел
    std::vector<long long> v3(5, 100);      // вектор из пяти чисел 100
}
```
### Методы front, back
Рассмотрим функции вектора `front` и `back`, которые возвращают его первый и последний элемент без использования индексов:
```cpp
std::vector<int> a = {1, 2, 3, 4, 5};
std::cout << a.front() << "\n";          // то же, что a[0]
std::cout << a.back() << "\n";           // то же, что a[data.size() - 1]
```
Важно учитывать, что вызов этих функций на пустом векторе приведёт к неопределённому поведению (UB).

Для проверки вектора на пустоту вместо сравнения `data.size() == 0` принято использовать функцию `empty`, которая возвращает логическое значение:
```cpp
if (!data.empty()) {
   // вектор не пуст, с ним можно работать
}
```

### Методы push_back, pop_back
В вектор можно эффективно добавлять элементы в конец и удалять их с конца. Для этого существуют функции `push_back` и `pop_back`. Рассмотрим программу, считывающую числа с клавиатуры в вектор и затем удаляющую все нули в конце:
```cpp
#include <iostream>
#include <vector>
 
int main() {
    int x;
    std::vector<int> a;
    while (std::cin >> x) {  // читаем числа, пока не закончится ввод
        a.push_back(x);  // добавляем очередное число в вектор
    }
 
    while (!a.empty() && a.back() == 0) {
        // Пока вектор не пуст и последний элемент равен нулю
        a.pop_back();  // удаляем этот нулевой элемент
    }
}
```
Добавление элементов в другие части вектора или их удаление неэффективно, так как требует сдвига соседних элементов. Поэтому отдельных функций, например, для добавления или удаления элементов из начала у вектора нет.

### Метод clear
Удалить все элементы из вектора можно с помощью функции `clear`.
```cpp
std::vector<int> a = {1, 2, 3, 4, 5};
a.clear();
std::cout << a.size();  \\ 0
```

### Сортировка вектора
Рассмотрим типичную задачу — отсортировать вектор по возрастанию. Для этого в стандартной библиотеке в заголовочном файле `algorithm` есть готовая функция `sort`. Гарантируется, что сложность её работы в худшем случае составляет $O(n\log n)$, где 
$n$ — число элементов в векторе.
```cpp
#include <algorithm>
#include <vector>
 
int main() {
    std::vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6};
 
    // Сортировка диапазона вектора от начала до конца
    std::sort(data.begin(), data.end());
 
    // получим вектор 1, 1, 2, 3, 4, 5, 6, 9
}
```
Для сортировки по убыванию:
```cpp
std::sort(data.rbegin(), data.rend());  // 9, 6, 5, 4, 3, 2, 1, 1
```

### Подробнее про строки
Контейнер `std::string` можно рассматривать как особый случай вектора символов `std::vector<char>`, имеющий набор дополнительных функций. В частности, у строки есть все те же рассмотренные нами функции, что и у вектора (`size`, `push_back` и т.д.)

Рассмотрим некоторые специфические функции строки:
```cpp
#include <iostream>
#include <string>
 
int main() {
    std::string s = "Some string";
 
    // приписывание символов и строк
    s += ' ';                // добавляем отдельный символ в конец, это аналог push_back
    s += "functions";        // добавляем строку в конец
    std::cout << s << "\n";  // Some string functions
}
```

## Указатели и ссылки
**Указатель** - переменная, значением которой является адрес ячейки памяти.
Здесь мы можем представлять себе память как длинную ленту с пронумерованным
и ячейками (байтами). 

Сам адрес переменной можно получить с помощью унарного оператора `&`.
```cpp
int main() {
    int x = 42;
    int* ptr = &x;    // сохраняем адрес в памяти переменной x в указатель ptr
 
    ++x;  // увеличим x на единицу
    std::cout << *ptr << "\n";    // 43
}
```
Чтобы получить значение переменной по указателю его необходимо разыменовать, то есть воспользоваться унарным оператором `*`.


![Снимок экрана 2023-07-31 222226](https://github.com/PolinaChubenko/LOSH-Aug-2023/assets/70897695/f054aea9-8280-47f8-972f-84598cff2e22)


Формально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он может быть преобразован к целому числу.
```cpp
int main() {
    int x = 1, y = 2, z = 3;
    std::cout << &x << "\n";    // 0x7ffdfee3188c
    std::cout << &y << "\n";    // 0x7ffdfee31888
    std::cout << &z << "\n";    // 0x7ffdfee31884
}
```
Операции, которые поддерживает указатель:
-  `*ptr` - унарная звездочка - разыменовывание (возвращает значение объекта)
-  `&ptr` - унарный амперсанд (возвращает адрес объекта в памяти)
- `+=, -=, ++, --`
- `prt + int`
- указатели можно сравнивать друг с другом. Указатели равны, если указывают на один и тот же объект, и не равны в противном случае.

Указатели можно инициализировать специальным значением нулевой указатель `nullptr`, которое сигнализирует об отсутствии привязки указателя к чему-либо:
```cpp
int main() {
    int* ptr = nullptr;
    int x = 5;
    ptr = &x;
    std::cout << *ptr;     // 5
}
```

Указатели можно передавать в функции и возвращать из функций как и любые “элементарные” значения. Ещё пример с указателями:
```cpp
int* max_byptr(int *a, int *b) {
    return *a < *b ? b : a;
}

int main() {
    int x = 5, y = 9;
    *max_byptr(&x, &y) = 42;
    std::cout << x << " " << y;      // 5 42
}
```
  
**Ссылка** - особый тип данных, являющийся скрытой формой указателя, который при использовании автоматически разыменовывается. 

Ссылка - это _новое название для уже существующей переменной_.
```cpp
#include <iostream>
 
int main() {
    int x = 42;
    int& ref = x;      // ссылка на x
 
    ++x;
    std::cout << ref << "\n";    // 43
}
```
Здесь `ref` - псевдоним для `x`. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. 
Формально типом `ref` является `int&` — ссылка на `int`.


Ссылка должна быть проинициализирована сразу в момент объявления. Например, так написать нельзя:
```cpp
int main() {
    int my_variable = 42;
    int& ref;      // ошибка!
    // ...
    ref = my_variable;
}
```
Ссылка привязана к одному и тому же объекту со своего рождения. Переназначить её нельзя:
```cpp
int main() {
    int x = 42, y = 13;
    int& ref = x;      // OK
    ref = y;           // ссылка останется привязанной к x, значение x поменяется
}
```
> Существует арифметика указателей, но нет арифметики ссылок.

#### Самое частое использование ссылок
При передаче параметров в функцию по ссылке передается ссылка на объект, через которую мы можем манипулировать самим объектов, а не просто его значением. 
```cpp
void foo(std::vector<int>& v) {
    for (int i = 0; i < v.size(); ++i) {
        std::cin >> v[i]
    }
}

int main() {
    std::vector<int> v(n);
    foo(v);
    // вектор v будет заполнен числами из консоли
}
```


## Виды памяти
1. **Стековая память** - память, в которой находятся все локальные переменные функций. Её у нас уловно где-то несколько мегабайт.
2. **Динамическая память** - некоторая память процесса, которая выдаётся нам по запросу (через new/malloc/calloc). Её гораздо больше, чем стековой (столько, сколько есть у всей системы). Обращение к ней происходит через указатели.
3. **Stack overflow** - переполнение стековой памяти. (Слишком глубокая рекурсия или обычный массив большого размера). Это RE
4. **Утечка памяти** - это когда вы выделили динамическую память, но не вернули её системе по окончании её использования (или при каком-то аварийном завершении).
