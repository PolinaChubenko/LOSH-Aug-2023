# База C++

## Первая программа
- в программе обязательно должна быть функция `main` - это главная исполняемая функция в программе 
- для ввода-вывода нужен заголовочный файл `iostream`
- `std::cin` - стандартный поток ввода, а `std::cout` - вывода
- символ перевода строки `\n` - это спецсимвол (все спецсимволы начинаются с `\`, например, `\t` - tab и т.д.)
- еще существует `std::endl`. Это тоже перенос строки, но отличие в том, что он очищает буфер вывода, а `\n` – нет

Код:

```
#include <iostream>

int main() {
    int a;     // объявляем целочисленную переменную a
    std::cin >> a;
    std::cout << a + 10 << '\n';
    std::cout << "success" << std::endl;
    return 0;
}
```

## Что такое компиляция?
При компиляции наш код превращается в исполняемый файл т.е. машинный код. 
Поэтому вызываем компилятор, чтобы преобразовать человекочитаемый код и машинный.

## Основные типы
С++ является статически-типизированным языком, то есть на момент компиляции все типы должны быть известны (в отличие от python).

Основные типы, с которым работают:


![types](https://github.com/PolinaChubenko/LOSH-Aug-2023/assets/70897695/433dbb9c-1a54-40f9-ba41-d755057b7dc7)


**Integer promotioin** : ''меньший'' тип приводится к ''большему''

## Вердикты CE, RE, UB
### CE - compiler error
Ошибка компиляции возникает, когда код написан некорректно с точки зрения языка. Из такого кода не получается создать исполняемый файл. Примеры:

1. Лексические: компилятор увидел последовательность символов, которую не смог расшифровать.
   - `(std) (::) (cout) (<<) (x) (;)` - пример корретного разбития на токены, и компилятор понял, что хочет программист
   - `)24abracadabra;` - тут все плохо
2. Синтаксическая: возникает, когда вы пишете инструкцию, недопустимую в соответствии с грамматикой языка (примером служит речь мастера Йоды).
   - `x + 5 + ;`
   - нет точки с запятой (;)
   - несоответствие круглых или фигурных скобок
3. Семантическая: возникает, когда инструкция написано корректно, но компилятор её выполнить не может (например: съешьте себя этим столом)
   - использование необъявленных переменных
   - вызов метода `size()` от переменной типа `int`
   - вызов `foo(3);` хотя сигнатура такая: `void foo(int a, int b) {}`

### RE - Runtime Error
Программа компилируется корректно, но в ходе выполнения она делает что-то непотребное. RE невозможно отследить на этапе компиляции (компилятор может разве что кинуть предупреждение в месте потенциальной ошибки). Примеры:

- слишком большая глубина рекурсии (stack overflow) => segmentation fault
- слишком далекий выход за границу массива => segmentation fault
- целочисленное деление на ноль (не всегда компилятор такое может предвидеть)


### UB - undefined behavior
Возникает при выполнении кода, когда результат исполнения которого не описан в стандарте. В случае UB компилятор волен сделать все что угодно (в теории компилятор может взорвать компьютер). UB может переродиться в CE, RE, или пройти незамеченным и нормально отработать.
- Чтение выделенной, но неинициализированной памяти. В теории, считается какой-то мусор, но технически, так как это UB, компилятор вправе поджечь ваш монитор
- Отсутствие return в конце функции, которая что-то возвращает. Шок, да? Это UB!
- Выход за границы C-style массива

## Виды памяти
1. **Стековая память** - память, в которой находятся все локальные переменные функций. Её у нас уловно где-то несколько мегабайт.
2. **Динамическая память** - некоторая память процесса, которая выдаётся нам по запросу (через new/malloc/calloc). Её гораздо больше, чем стековой (столько, сколько есть у всей системы). Обращение к ней происходит через указатели.
3. **Stack overflow** - переполнение стековой памяти. (Слишком глубокая рекурсия или обычный массив большого размера). Это RE
4. **Утечка памяти** - это когда вы выделили динамическую память, но не вернули её системе по окончании её использования (или при каком-то аварийном завершении).

## Указатели и ссылки
**Указатель** - переменная, значением которой является адрес ячейки памяти.
Здесь мы можем представлять себе память как длинную ленту с пронумерованным
и ячейками (байтами). 

Сам адрес переменной можно получить с помощью унарного оператора `&`.
```
int main() {
    int x = 42;
    int* ptr = &x;    // сохраняем адрес в памяти переменной x в указатель ptr
 
    ++x;  // увеличим x на единицу
    std::cout << *ptr << "\n";    // 43
}
```
Чтобы получить значение переменной по указателю его необходимо разыменовать, то есть воспользоваться унарным оператором `*`.


![Снимок экрана 2023-07-31 222226](https://github.com/PolinaChubenko/LOSH-Aug-2023/assets/70897695/f054aea9-8280-47f8-972f-84598cff2e22)


Формально указатель — это не номер ячейки памяти, а отдельный тип. Но обычно он может быть преобразован к целому числу.
```
#include <iostream>
 
int main() {
    int x = 1, y = 2, z = 3;
    std::cout << &x << "\n";    // 0x7ffdfee3188c
    std::cout << &y << "\n";    // 0x7ffdfee31888
    std::cout << &z << "\n";    // 0x7ffdfee31884
}
```
Операции, которые поддерживает указатель:
-  `*ptr` - унарная звездочка - разыменовывание (возвращает значение объекта)
-  `&ptr` - унарный амперсанд (возвращает адрес объекта в памяти)
- `+=, -=, ++, --`
- `prt + int`
- указатели можно сравнивать друг с другом. Указатели равны, если указывают на один и тот же объект, и не равны в противном случае.

Мы можем создать пустой указатель
```
int main() {
    int* ptr = nullptr;
    int x = 5;
    ptr = &x;
    std::cout << *ptr;     // 5
}
```

Указатели можно передавать в функции и возвращать из функций как и любые “элементарные” значения. Ещё пример с указателями:
```
int* max_byptr(int *a, int *b) {
    return *a < *b ? b : a;
}

int main() {
    int x = 5, y = 9;
    *max_byptr(&x, &y) = 42;
    std::cout << x << " " << y;      // 5 42
}
```
  
**Ссылка** - особый тип данных, являющийся скрытой формой указателя, который при использовании автоматически разыменовывается. 

Ссылка - это _новое название для уже существующей переменной_.
```
#include <iostream>
 
int main() {
    int x = 42;
    int& ref = x;      // ссылка на x
 
    ++x;
    std::cout << ref << "\n";    // 43
}
```
Здесь `ref` - псевдоним для `x`. Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти. 
Формально типом `ref` является `int&` — ссылка на `int`.


Ссылка должна быть проинициализирована сразу в момент объявления. Например, так написать нельзя:
```
int main() {
    int my_variable = 42;
    int& ref;      // ошибка!
    // ...
    ref = my_variable;
}
```
Ссылка привязана к одному и тому же объекту со своего рождения. Переназначить её нельзя:
```
int main() {
    int x = 42, y = 13;
    int& ref = x;      // OK
    ref = y;           // ссылка останется привязанной к x, значение x поменяется
}
```
**!** Существует арифметика указателей, но нет арифметики ссылок.

#### Самое частое использование ссылок
При передаче параметров в функцию по ссылке передается ссылка на объект, через которую мы можем манипулировать самим объектов, а не просто его значением. 
```
void foo(std::vector<int>& v) {
    for (int i = 0; i < v.size(); ++i) {
        std::cin >> v[i]
    }
}

int main() {
    std::vector<int> v(n);
    foo(v);
    // вектор v будет заполнен числами из консоли
}
```
